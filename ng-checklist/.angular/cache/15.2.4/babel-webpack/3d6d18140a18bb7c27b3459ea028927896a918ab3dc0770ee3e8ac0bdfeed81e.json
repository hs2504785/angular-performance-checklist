{"ast":null,"code":"// https://github.com/farzher/fuzzysort v2.0.4\n/*\r\n  SublimeText-like Fuzzy Search\r\n\r\n  fuzzysort.single('fs', 'Fuzzy Search') // {score: -16}\r\n  fuzzysort.single('test', 'test') // {score: 0}\r\n  fuzzysort.single('doesnt exist', 'target') // null\r\n\r\n  fuzzysort.go('mr', [{file:'Monitor.cpp'}, {file:'MeshRenderer.cpp'}], {key:'file'})\r\n  // [{score:-18, obj:{file:'MeshRenderer.cpp'}}, {score:-6009, obj:{file:'Monitor.cpp'}}]\r\n\r\n  fuzzysort.go('mr', ['Monitor.cpp', 'MeshRenderer.cpp'])\r\n  // [{score: -18, target: \"MeshRenderer.cpp\"}, {score: -6009, target: \"Monitor.cpp\"}]\r\n\r\n  fuzzysort.highlight(fuzzysort.single('fs', 'Fuzzy Search'), '<b>', '</b>')\r\n  // <b>F</b>uzzy <b>S</b>earch\r\n*/\n\n// UMD (Universal Module Definition) for fuzzysort\n;\n((root, UMD) => {\n  if (typeof define === 'function' && define.amd) define([], UMD);else if (typeof module === 'object' && module.exports) module.exports = UMD();else root['fuzzysort'] = UMD();\n})(this, _ => {\n  'use strict';\n\n  var single = (search, target) => {\n    if (search == 'farzher') return {\n      target: \"farzher was here (^-^*)/\",\n      score: 0,\n      _indexes: [0]\n    };\n    if (!search || !target) return NULL;\n    var preparedSearch = getPreparedSearch(search);\n    if (!isObj(target)) target = getPrepared(target);\n    var searchBitflags = preparedSearch.bitflags;\n    if ((searchBitflags & target._bitflags) !== searchBitflags) return NULL;\n    return algorithm(preparedSearch, target);\n  };\n  var go = (search, targets, options) => {\n    if (search == 'farzher') return [{\n      target: \"farzher was here (^-^*)/\",\n      score: 0,\n      _indexes: [0],\n      obj: targets ? targets[0] : NULL\n    }];\n    if (!search) return options && options.all ? all(search, targets, options) : noResults;\n    var preparedSearch = getPreparedSearch(search);\n    var searchBitflags = preparedSearch.bitflags;\n    var containsSpace = preparedSearch.containsSpace;\n    var threshold = options && options.threshold || INT_MIN;\n    var limit = options && options['limit'] || INT_MAX; // for some reason only limit breaks when minified\n\n    var resultsLen = 0;\n    var limitedCount = 0;\n    var targetsLen = targets.length;\n\n    // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n\n    // options.key\n    if (options && options.key) {\n      var key = options.key;\n      for (var i = 0; i < targetsLen; ++i) {\n        var obj = targets[i];\n        var target = getValue(obj, key);\n        if (!target) continue;\n        if (!isObj(target)) target = getPrepared(target);\n        if ((searchBitflags & target._bitflags) !== searchBitflags) continue;\n        var result = algorithm(preparedSearch, target);\n        if (result === NULL) continue;\n        if (result.score < threshold) continue;\n\n        // have to clone result so duplicate targets from different obj can each reference the correct obj\n        result = {\n          target: result.target,\n          _targetLower: '',\n          _targetLowerCodes: NULL,\n          _nextBeginningIndexes: NULL,\n          _bitflags: 0,\n          score: result.score,\n          _indexes: result._indexes,\n          obj: obj\n        }; // hidden\n\n        if (resultsLen < limit) {\n          q.add(result);\n          ++resultsLen;\n        } else {\n          ++limitedCount;\n          if (result.score > q.peek().score) q.replaceTop(result);\n        }\n      }\n\n      // options.keys\n    } else if (options && options.keys) {\n      var scoreFn = options['scoreFn'] || defaultScoreFn;\n      var keys = options.keys;\n      var keysLen = keys.length;\n      for (var i = 0; i < targetsLen; ++i) {\n        var obj = targets[i];\n        var objResults = new Array(keysLen);\n        for (var keyI = 0; keyI < keysLen; ++keyI) {\n          var key = keys[keyI];\n          var target = getValue(obj, key);\n          if (!target) {\n            objResults[keyI] = NULL;\n            continue;\n          }\n          if (!isObj(target)) target = getPrepared(target);\n          if ((searchBitflags & target._bitflags) !== searchBitflags) objResults[keyI] = NULL;else objResults[keyI] = algorithm(preparedSearch, target);\n        }\n        objResults.obj = obj; // before scoreFn so scoreFn can use it\n        var score = scoreFn(objResults);\n        if (score === NULL) continue;\n        if (score < threshold) continue;\n        objResults.score = score;\n        if (resultsLen < limit) {\n          q.add(objResults);\n          ++resultsLen;\n        } else {\n          ++limitedCount;\n          if (score > q.peek().score) q.replaceTop(objResults);\n        }\n      }\n\n      // no keys\n    } else {\n      for (var i = 0; i < targetsLen; ++i) {\n        var target = targets[i];\n        if (!target) continue;\n        if (!isObj(target)) target = getPrepared(target);\n        if ((searchBitflags & target._bitflags) !== searchBitflags) continue;\n        var result = algorithm(preparedSearch, target);\n        if (result === NULL) continue;\n        if (result.score < threshold) continue;\n        if (resultsLen < limit) {\n          q.add(result);\n          ++resultsLen;\n        } else {\n          ++limitedCount;\n          if (result.score > q.peek().score) q.replaceTop(result);\n        }\n      }\n    }\n    if (resultsLen === 0) return noResults;\n    var results = new Array(resultsLen);\n    for (var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll();\n    results.total = resultsLen + limitedCount;\n    return results;\n  };\n  var highlight = (result, hOpen, hClose) => {\n    if (typeof hOpen === 'function') return highlightCallback(result, hOpen);\n    if (result === NULL) return NULL;\n    if (hOpen === undefined) hOpen = '<b>';\n    if (hClose === undefined) hClose = '</b>';\n    var highlighted = '';\n    var matchesIndex = 0;\n    var opened = false;\n    var target = result.target;\n    var targetLen = target.length;\n    var indexes = result._indexes;\n    indexes = indexes.slice(0, indexes.len).sort((a, b) => a - b);\n    for (var i = 0; i < targetLen; ++i) {\n      var char = target[i];\n      if (indexes[matchesIndex] === i) {\n        ++matchesIndex;\n        if (!opened) {\n          opened = true;\n          highlighted += hOpen;\n        }\n        if (matchesIndex === indexes.length) {\n          highlighted += char + hClose + target.substr(i + 1);\n          break;\n        }\n      } else {\n        if (opened) {\n          opened = false;\n          highlighted += hClose;\n        }\n      }\n      highlighted += char;\n    }\n    return highlighted;\n  };\n  var highlightCallback = (result, cb) => {\n    if (result === NULL) return NULL;\n    var target = result.target;\n    var targetLen = target.length;\n    var indexes = result._indexes;\n    indexes = indexes.slice(0, indexes.len).sort((a, b) => a - b);\n    var highlighted = '';\n    var matchI = 0;\n    var indexesI = 0;\n    var opened = false;\n    var result = [];\n    for (var i = 0; i < targetLen; ++i) {\n      var char = target[i];\n      if (indexes[indexesI] === i) {\n        ++indexesI;\n        if (!opened) {\n          opened = true;\n          result.push(highlighted);\n          highlighted = '';\n        }\n        if (indexesI === indexes.length) {\n          highlighted += char;\n          result.push(cb(highlighted, matchI++));\n          highlighted = '';\n          result.push(target.substr(i + 1));\n          break;\n        }\n      } else {\n        if (opened) {\n          opened = false;\n          result.push(cb(highlighted, matchI++));\n          highlighted = '';\n        }\n      }\n      highlighted += char;\n    }\n    return result;\n  };\n  var indexes = result => result._indexes.slice(0, result._indexes.len).sort((a, b) => a - b);\n  var prepare = target => {\n    if (typeof target !== 'string') target = '';\n    var info = prepareLowerInfo(target);\n    return {\n      'target': target,\n      _targetLower: info._lower,\n      _targetLowerCodes: info.lowerCodes,\n      _nextBeginningIndexes: NULL,\n      _bitflags: info.bitflags,\n      'score': NULL,\n      _indexes: [0],\n      'obj': NULL\n    }; // hidden\n  };\n\n  // Below this point is only internal code\n  // Below this point is only internal code\n  // Below this point is only internal code\n  // Below this point is only internal code\n\n  var prepareSearch = search => {\n    if (typeof search !== 'string') search = '';\n    search = search.trim();\n    var info = prepareLowerInfo(search);\n    var spaceSearches = [];\n    if (info.containsSpace) {\n      var searches = search.split(/\\s+/);\n      searches = [...new Set(searches)]; // distinct\n      for (var i = 0; i < searches.length; i++) {\n        if (searches[i] === '') continue;\n        var _info = prepareLowerInfo(searches[i]);\n        spaceSearches.push({\n          lowerCodes: _info.lowerCodes,\n          _lower: searches[i].toLowerCase(),\n          containsSpace: false\n        });\n      }\n    }\n    return {\n      lowerCodes: info.lowerCodes,\n      bitflags: info.bitflags,\n      containsSpace: info.containsSpace,\n      _lower: info._lower,\n      spaceSearches: spaceSearches\n    };\n  };\n  var getPrepared = target => {\n    if (target.length > 999) return prepare(target); // don't cache huge targets\n    var targetPrepared = preparedCache.get(target);\n    if (targetPrepared !== undefined) return targetPrepared;\n    targetPrepared = prepare(target);\n    preparedCache.set(target, targetPrepared);\n    return targetPrepared;\n  };\n  var getPreparedSearch = search => {\n    if (search.length > 999) return prepareSearch(search); // don't cache huge searches\n    var searchPrepared = preparedSearchCache.get(search);\n    if (searchPrepared !== undefined) return searchPrepared;\n    searchPrepared = prepareSearch(search);\n    preparedSearchCache.set(search, searchPrepared);\n    return searchPrepared;\n  };\n  var all = (search, targets, options) => {\n    var results = [];\n    results.total = targets.length;\n    var limit = options && options.limit || INT_MAX;\n    if (options && options.key) {\n      for (var i = 0; i < targets.length; i++) {\n        var obj = targets[i];\n        var target = getValue(obj, options.key);\n        if (!target) continue;\n        if (!isObj(target)) target = getPrepared(target);\n        target.score = INT_MIN;\n        target._indexes.len = 0;\n        var result = target;\n        result = {\n          target: result.target,\n          _targetLower: '',\n          _targetLowerCodes: NULL,\n          _nextBeginningIndexes: NULL,\n          _bitflags: 0,\n          score: target.score,\n          _indexes: NULL,\n          obj: obj\n        }; // hidden\n        results.push(result);\n        if (results.length >= limit) return results;\n      }\n    } else if (options && options.keys) {\n      for (var i = 0; i < targets.length; i++) {\n        var obj = targets[i];\n        var objResults = new Array(options.keys.length);\n        for (var keyI = options.keys.length - 1; keyI >= 0; --keyI) {\n          var target = getValue(obj, options.keys[keyI]);\n          if (!target) {\n            objResults[keyI] = NULL;\n            continue;\n          }\n          if (!isObj(target)) target = getPrepared(target);\n          target.score = INT_MIN;\n          target._indexes.len = 0;\n          objResults[keyI] = target;\n        }\n        objResults.obj = obj;\n        objResults.score = INT_MIN;\n        results.push(objResults);\n        if (results.length >= limit) return results;\n      }\n    } else {\n      for (var i = 0; i < targets.length; i++) {\n        var target = targets[i];\n        if (!target) continue;\n        if (!isObj(target)) target = getPrepared(target);\n        target.score = INT_MIN;\n        target._indexes.len = 0;\n        results.push(target);\n        if (results.length >= limit) return results;\n      }\n    }\n    return results;\n  };\n  var algorithm = (preparedSearch, prepared, allowSpaces = false) => {\n    if (allowSpaces === false && preparedSearch.containsSpace) return algorithmSpaces(preparedSearch, prepared);\n    var searchLower = preparedSearch._lower;\n    var searchLowerCodes = preparedSearch.lowerCodes;\n    var searchLowerCode = searchLowerCodes[0];\n    var targetLowerCodes = prepared._targetLowerCodes;\n    var searchLen = searchLowerCodes.length;\n    var targetLen = targetLowerCodes.length;\n    var searchI = 0; // where we at\n    var targetI = 0; // where you at\n    var matchesSimpleLen = 0;\n\n    // very basic fuzzy match; to remove non-matching targets ASAP!\n    // walk through target. find sequential matches.\n    // if all chars aren't found then exit\n    for (;;) {\n      var isMatch = searchLowerCode === targetLowerCodes[targetI];\n      if (isMatch) {\n        matchesSimple[matchesSimpleLen++] = targetI;\n        ++searchI;\n        if (searchI === searchLen) break;\n        searchLowerCode = searchLowerCodes[searchI];\n      }\n      ++targetI;\n      if (targetI >= targetLen) return NULL; // Failed to find searchI\n    }\n\n    var searchI = 0;\n    var successStrict = false;\n    var matchesStrictLen = 0;\n    var nextBeginningIndexes = prepared._nextBeginningIndexes;\n    if (nextBeginningIndexes === NULL) nextBeginningIndexes = prepared._nextBeginningIndexes = prepareNextBeginningIndexes(prepared.target);\n    var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n\n    // Our target string successfully matched all characters in sequence!\n    // Let's try a more advanced and strict test to improve the score\n    // only count it as a match if it's consecutive or a beginning character!\n    var backtrackCount = 0;\n    if (targetI !== targetLen) for (;;) {\n      if (targetI >= targetLen) {\n        // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n        if (searchI <= 0) break; // We failed to push chars forward for a better match\n\n        ++backtrackCount;\n        if (backtrackCount > 200) break; // exponential backtracking is taking too long, just give up and return a bad match\n\n        --searchI;\n        var lastMatch = matchesStrict[--matchesStrictLen];\n        targetI = nextBeginningIndexes[lastMatch];\n      } else {\n        var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];\n        if (isMatch) {\n          matchesStrict[matchesStrictLen++] = targetI;\n          ++searchI;\n          if (searchI === searchLen) {\n            successStrict = true;\n            break;\n          }\n          ++targetI;\n        } else {\n          targetI = nextBeginningIndexes[targetI];\n        }\n      }\n    }\n\n    // check if it's a substring match\n    var substringIndex = prepared._targetLower.indexOf(searchLower, matchesSimple[0]); // perf: this is slow\n    var isSubstring = ~substringIndex;\n    if (isSubstring && !successStrict) {\n      // rewrite the indexes from basic to the substring\n      for (var i = 0; i < matchesSimpleLen; ++i) matchesSimple[i] = substringIndex + i;\n    }\n    var isSubstringBeginning = false;\n    if (isSubstring) {\n      isSubstringBeginning = prepared._nextBeginningIndexes[substringIndex - 1] === substringIndex;\n    }\n    {\n      // tally up the score & keep track of matches for highlighting later\n      if (successStrict) {\n        var matchesBest = matchesStrict;\n        var matchesBestLen = matchesStrictLen;\n      } else {\n        var matchesBest = matchesSimple;\n        var matchesBestLen = matchesSimpleLen;\n      }\n      var score = 0;\n      var extraMatchGroupCount = 0;\n      for (var i = 1; i < searchLen; ++i) {\n        if (matchesBest[i] - matchesBest[i - 1] !== 1) {\n          score -= matchesBest[i];\n          ++extraMatchGroupCount;\n        }\n      }\n      var unmatchedDistance = matchesBest[searchLen - 1] - matchesBest[0] - (searchLen - 1);\n      score -= (12 + unmatchedDistance) * extraMatchGroupCount; // penality for more groups\n\n      if (matchesBest[0] !== 0) score -= matchesBest[0] * matchesBest[0] * .2; // penality for not starting near the beginning\n\n      if (!successStrict) {\n        score *= 1000;\n      } else {\n        // successStrict on a target with too many beginning indexes loses points for being a bad target\n        var uniqueBeginningIndexes = 1;\n        for (var i = nextBeginningIndexes[0]; i < targetLen; i = nextBeginningIndexes[i]) ++uniqueBeginningIndexes;\n        if (uniqueBeginningIndexes > 24) score *= (uniqueBeginningIndexes - 24) * 10; // quite arbitrary numbers here ...\n      }\n\n      if (isSubstring) score /= 1 + searchLen * searchLen * 1; // bonus for being a full substring\n      if (isSubstringBeginning) score /= 1 + searchLen * searchLen * 1; // bonus for substring starting on a beginningIndex\n\n      score -= targetLen - searchLen; // penality for longer targets\n      prepared.score = score;\n      for (var i = 0; i < matchesBestLen; ++i) prepared._indexes[i] = matchesBest[i];\n      prepared._indexes.len = matchesBestLen;\n      return prepared;\n    }\n  };\n  var algorithmSpaces = (preparedSearch, target) => {\n    var seen_indexes = new Set();\n    var score = 0;\n    var result = NULL;\n    var first_seen_index_last_search = 0;\n    var searches = preparedSearch.spaceSearches;\n    for (var i = 0; i < searches.length; ++i) {\n      var search = searches[i];\n      result = algorithm(search, target);\n      if (result === NULL) return NULL;\n      score += result.score;\n\n      // dock points based on order otherwise \"c man\" returns Manifest.cpp instead of CheatManager.h\n      if (result._indexes[0] < first_seen_index_last_search) {\n        score -= first_seen_index_last_search - result._indexes[0];\n      }\n      first_seen_index_last_search = result._indexes[0];\n      for (var j = 0; j < result._indexes.len; ++j) seen_indexes.add(result._indexes[j]);\n    }\n\n    // allows a search with spaces that's an exact substring to score well\n    var allowSpacesResult = algorithm(preparedSearch, target, /*allowSpaces=*/true);\n    if (allowSpacesResult !== NULL && allowSpacesResult.score > score) {\n      return allowSpacesResult;\n    }\n    result.score = score;\n    var i = 0;\n    for (let index of seen_indexes) result._indexes[i++] = index;\n    result._indexes.len = i;\n    return result;\n  };\n  var prepareLowerInfo = str => {\n    var strLen = str.length;\n    var lower = str.toLowerCase();\n    var lowerCodes = []; // new Array(strLen)    sparse array is too slow\n    var bitflags = 0;\n    var containsSpace = false; // space isn't stored in bitflags because of how searching with a space works\n\n    for (var i = 0; i < strLen; ++i) {\n      var lowerCode = lowerCodes[i] = lower.charCodeAt(i);\n      if (lowerCode === 32) {\n        containsSpace = true;\n        continue; // it's important that we don't set any bitflags for space\n      }\n\n      var bit = lowerCode >= 97 && lowerCode <= 122 ? lowerCode - 97 // alphabet\n      : lowerCode >= 48 && lowerCode <= 57 ? 26 // numbers\n      // 3 bits available\n      : lowerCode <= 127 ? 30 // other ascii\n      : 31; // other utf8\n      bitflags |= 1 << bit;\n    }\n    return {\n      lowerCodes: lowerCodes,\n      bitflags: bitflags,\n      containsSpace: containsSpace,\n      _lower: lower\n    };\n  };\n  var prepareBeginningIndexes = target => {\n    var targetLen = target.length;\n    var beginningIndexes = [];\n    var beginningIndexesLen = 0;\n    var wasUpper = false;\n    var wasAlphanum = false;\n    for (var i = 0; i < targetLen; ++i) {\n      var targetCode = target.charCodeAt(i);\n      var isUpper = targetCode >= 65 && targetCode <= 90;\n      var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;\n      var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;\n      wasUpper = isUpper;\n      wasAlphanum = isAlphanum;\n      if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;\n    }\n    return beginningIndexes;\n  };\n  var prepareNextBeginningIndexes = target => {\n    var targetLen = target.length;\n    var beginningIndexes = prepareBeginningIndexes(target);\n    var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow\n    var lastIsBeginning = beginningIndexes[0];\n    var lastIsBeginningI = 0;\n    for (var i = 0; i < targetLen; ++i) {\n      if (lastIsBeginning > i) {\n        nextBeginningIndexes[i] = lastIsBeginning;\n      } else {\n        lastIsBeginning = beginningIndexes[++lastIsBeginningI];\n        nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;\n      }\n    }\n    return nextBeginningIndexes;\n  };\n  var cleanup = () => {\n    preparedCache.clear();\n    preparedSearchCache.clear();\n    matchesSimple = [];\n    matchesStrict = [];\n  };\n  var preparedCache = new Map();\n  var preparedSearchCache = new Map();\n  var matchesSimple = [];\n  var matchesStrict = [];\n\n  // for use with keys. just returns the maximum score\n  var defaultScoreFn = a => {\n    var max = INT_MIN;\n    var len = a.length;\n    for (var i = 0; i < len; ++i) {\n      var result = a[i];\n      if (result === NULL) continue;\n      var score = result.score;\n      if (score > max) max = score;\n    }\n    if (max === INT_MIN) return NULL;\n    return max;\n  };\n\n  // prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n  // prop = 'key1.key2'        10ms\n  // prop = ['key1', 'key2']   27ms\n  var getValue = (obj, prop) => {\n    var tmp = obj[prop];\n    if (tmp !== undefined) return tmp;\n    var segs = prop;\n    if (!Array.isArray(prop)) segs = prop.split('.');\n    var len = segs.length;\n    var i = -1;\n    while (obj && ++i < len) obj = obj[segs[i]];\n    return obj;\n  };\n  var isObj = x => {\n    return typeof x === 'object';\n  }; // faster as a function\n  // var INT_MAX = 9007199254740991; var INT_MIN = -INT_MAX\n  var INT_MAX = Infinity;\n  var INT_MIN = -INT_MAX;\n  var noResults = [];\n  noResults.total = 0;\n  var NULL = null;\n\n  // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n  var fastpriorityqueue = r => {\n    var e = [],\n      o = 0,\n      a = {},\n      v = r => {\n        for (var a = 0, v = e[a], c = 1; c < o;) {\n          var s = c + 1;\n          a = c, s < o && e[s].score < e[c].score && (a = s), e[a - 1 >> 1] = e[a], c = 1 + (a << 1);\n        }\n        for (var f = a - 1 >> 1; a > 0 && v.score < e[f].score; f = (a = f) - 1 >> 1) e[a] = e[f];\n        e[a] = v;\n      };\n    return a.add = r => {\n      var a = o;\n      e[o++] = r;\n      for (var v = a - 1 >> 1; a > 0 && r.score < e[v].score; v = (a = v) - 1 >> 1) e[a] = e[v];\n      e[a] = r;\n    }, a.poll = r => {\n      if (0 !== o) {\n        var a = e[0];\n        return e[0] = e[--o], v(), a;\n      }\n    }, a.peek = r => {\n      if (0 !== o) return e[0];\n    }, a.replaceTop = r => {\n      e[0] = r, v();\n    }, a;\n  };\n  var q = fastpriorityqueue(); // reuse this\n\n  // fuzzysort is written this way for minification. all names are mangeled unless quoted\n  return {\n    'single': single,\n    'go': go,\n    'highlight': highlight,\n    'prepare': prepare,\n    'indexes': indexes,\n    'cleanup': cleanup\n  };\n}); // UMD\n\n// TODO: (feature) frecency\n// TODO: (perf) use different sorting algo depending on the # of results?\n// TODO: (perf) preparedCache is a memory leak\n// TODO: (like sublime) backslash === forwardslash\n// TODO: (perf) prepareSearch seems slow","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}